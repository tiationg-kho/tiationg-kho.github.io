<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Array on Tiationg's Portfolio</title><link>https://tiationg-kho.github.io/tags/array/</link><description>Recent content in Array on Tiationg's Portfolio</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 14 Jun 2024 00:08:22 -0700</lastBuildDate><atom:link href="https://tiationg-kho.github.io/tags/array/index.xml" rel="self" type="application/rss+xml"/><item><title>Array</title><link>https://tiationg-kho.github.io/blog/2024/06/13/array/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/array/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems array array intro array contiguous in memory in dynamic arrays, amortized O(1) for appending array pattern traverse most common operation in array use Boyer Moore vote algorithm can find possible majority element(s) first travserse (finding candidate(s)) if this element is existing candidate, then increment voting count for if we do not have enough candidate(s), then add new candidate if this element is not a candidate, then decrement each existing voting count and remove candidate(s) if needed second traverse (verifying candidate(s)) calc the frequency of candidate(s) filter the final res notice: the order of these steps matters def get_top_k_majority(k): cand_vote = {} for num in nums: if num in cand_vote: cand_vote[num] += 1 elif len(cand_vote) &amp;lt; k: cand_vote[num] = 1 else: for c in list(cand_vote.</description></item></channel></rss>