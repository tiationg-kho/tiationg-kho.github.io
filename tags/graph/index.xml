<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Graph on Tiationg's Portfolio</title><link>https://tiationg-kho.github.io/tags/graph/</link><description>Recent content in Graph on Tiationg's Portfolio</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 14 Jun 2024 00:08:22 -0700</lastBuildDate><atom:link href="https://tiationg-kho.github.io/tags/graph/index.xml" rel="self" type="application/rss+xml"/><item><title>Graph</title><link>https://tiationg-kho.github.io/blog/2024/06/13/graph/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/graph/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems graph intro A graph is most commonly stored as a hashmap/list of adjacency lists/sets: for each vertex, store a list/set of its neighbors how to build graph is important often use elements inside set can be tuples graph = defaultdict(set) notice: tree is a special graph with properties that connected acyclic non-direction edges one path between any two vertices/nodes graph dfs pattern DFS time O(|V| + |E|) space O(|V|) for visited hashset, and recursion stack (not counting building graph) DFS is better at searching for long paths memorizing res for long paths detecting cycles # dfs graph = defaultdict(set) for p, q in edges: graph[p].</description></item></channel></rss>