<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Heap on Tiationg's Portfolio</title><link>https://tiationg-kho.github.io/tags/heap/</link><description>Recent content in Heap on Tiationg's Portfolio</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 14 Jun 2024 00:08:22 -0700</lastBuildDate><atom:link href="https://tiationg-kho.github.io/tags/heap/index.xml" rel="self" type="application/rss+xml"/><item><title>Heap</title><link>https://tiationg-kho.github.io/blog/2024/06/13/heap/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/heap/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems heap intro heap is a data structure (binary heap)
support insert in O(log(n)) insert as last element swim up the last element support delete_min or delete_max in O(log(n)) swap the top element with last element pop last element (which is old top element) sink down the (new) top element heapify(nums) takes O(n) time checking and performing sink down start from last element to top element why sink down every element is not O(nlogn) time because the higher layer, which node would cost more, actually have few nodes inside the layer O(1) to get the min val in min heap, or max val in max heap get the top element min heap</description></item></channel></rss>