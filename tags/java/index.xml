<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Tiationg's Portfolio</title><link>https://tiationg-kho.github.io/tags/java/</link><description>Recent content in Java on Tiationg's Portfolio</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 14 Jun 2024 00:08:22 -0700</lastBuildDate><atom:link href="https://tiationg-kho.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Keyword</title><link>https://tiationg-kho.github.io/blog/2024/06/13/keyword/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/keyword/</guid><description>Keyword Access Modifiers public protected default (no keyword required) private Non-Access Modifiers static final abstract synchronized volatile Class-Related Keywords class extends interface implements enum record Object-Related Keywords new this super Method-Related Keywords void return Control Flow Statements for while do while continue break if, else if, else switch, case, default Exception Handling try, catch, finally throw (used to explicitly throw an exception) throws (used to declare that a method can throw exceptions) Primitive Types Boolean boolean (1 bit in Theory) (Wrapper Class is Boolean) Character char (16 bits) (Wrapper Class is Character) Integer byte (8 bits) (Wrapper Class is Byte) short (16 bits) (Wrapper Class is Short) int (32 bits) (Wrapper Class is Integer) long (64 bits) (Wrapper Class is Long) Floating-Point float (32 bits) (Wrapper Class is Float) double (64 bits) (Wrapper Class is Double) Package-Related Keywords package import Literals (not keywords) true false null</description></item><item><title>JDK vs JRE vs JVM</title><link>https://tiationg-kho.github.io/blog/2024/06/13/jdk-vs-jre-vs-jvm/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/jdk-vs-jre-vs-jvm/</guid><description>JDK vs JRE vs JVM JDK (Java Development Kit) JRE (Java Runtime Environment) JVM (Java Virtual Machine) Definition Development toolkit for Java Runtime environment for Java Abstract machine to run Java bytecode Components JRE + development tools (compiler, etc.) JVM + core libraries Bytecode interpreter, JIT compiler Usage Writing, compiling, debugging Java apps Running Java applications Executing Java bytecode</description></item><item><title>Object vs Class</title><link>https://tiationg-kho.github.io/blog/2024/06/13/object-vs-class/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/object-vs-class/</guid><description>Object vs Class Class Object Definition Blueprint for creating objects Instance of a class public class Main { public static void main(String[] args) { Car myCar = new Car(&amp;#34;Toyota&amp;#34;, 2000); myCar.displayInfo(); // Make by Toyota in 2000 } } class Car { private String make; private int year; public Car(String make, int year) { this.make = make; this.year = year; } public void displayInfo() { System.out.println(&amp;#34;Make by &amp;#34; + make + &amp;#34; in &amp;#34; + year); } }</description></item><item><title>Constructor</title><link>https://tiationg-kho.github.io/blog/2024/06/13/constructor/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/constructor/</guid><description>Constructor A special method used to initialize objects The constructor has the same name as the class It does not have a return type, not even void It can be overloaded to accept different parameters Type Default Constructor Automatically provided by Java if no other constructors are defined It initializes object with default values Parameterized Constructor It initializes object with specific values through parameters</description></item><item><title>Encapsulation</title><link>https://tiationg-kho.github.io/blog/2024/06/13/encapsulation/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/encapsulation/</guid><description>Encapsulation Protect and control access to data Access Modifiers Java provides several access modifiers to set access levels for classes, variables, and methods public Can be accessed from any other class protected Can be accessed from its own package or subclasses default (no keyword required) Can be accessed from its own package private Can be accessed only from its own class Getter and Setter Methods We can use public getter/setter methods to access/modify the private variables</description></item><item><title>Inheritance</title><link>https://tiationg-kho.github.io/blog/2024/06/13/inheritance/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/inheritance/</guid><description>Inheritance Reusing code across classes (creating PARENT-CHILD relationship) extends Used in class declarations to create a subclass that inherits fields and methods from a superclass @Override Subclasses can override methods of the superclass to provide specific implementations super() Calling the superclass constructor in subclass constructor super Refer to parent class object in subclass public class Main { public static void main(String[] args) { Dog myDog = new Dog(); /* Animal is created.</description></item><item><title>Polymorphism</title><link>https://tiationg-kho.github.io/blog/2024/06/13/polymorphism/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/polymorphism/</guid><description>Polymorphism Same name, different execution Method Overloading Compile-Time Polymorphism Static binding Same method name, different parameter lists Different parameter lists are decided by different number/type/order of parameters Method Overriding Runtime Polymorphism Dynamic binding Same method name and parameter list, but different implementations in different classes (superclass and subclass) Require inheritance and using @Override</description></item><item><title>Abstraction</title><link>https://tiationg-kho.github.io/blog/2024/06/13/abstraction/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/abstraction/</guid><description>Abstraction Hide complexity, show essentials abstract class vs interface abstract class interface Inheritance Supports single inheritance Supports multiple inheritances Subclass Use extends to inherit Use implements to inherit Instantiation Cannot be instantiated Cannot be instantiated Constructor Can have constructors Cannot have constructors Method Accessibility Methods can be public, protected, default, or private Methods are public by default Method Implementation Methods can be abstract or concrete Methods are abstract by default Fields Field can be final, non-final, static, non-static, public, protected, default, or private All fields are public, static, and final by default</description></item><item><title>Stack vs Heap</title><link>https://tiationg-kho.github.io/blog/2024/06/13/stack-vs-heap/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/stack-vs-heap/</guid><description>Stack vs Heap Stack Heap Store Method calls, primitive types, reference to objects Objects Management Automatic Manual or Automatic (Garbage Collector)</description></item><item><title>Garbage Collection</title><link>https://tiationg-kho.github.io/blog/2024/06/13/garbage-collection/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/garbage-collection/</guid><description>Garbage Collection Garbage Collection (GC) in Java is a form of automatic memory management The garbage collector identifies which objects are no longer being used by the application</description></item><item><title>final vs finally vs finalize</title><link>https://tiationg-kho.github.io/blog/2024/06/13/final-vs-finally-vs-finalize/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/final-vs-finally-vs-finalize/</guid><description>final vs finally vs finalize final finally finalize Usage Prevents modification (variables), overriding (methods), or inheritance (classes) Use in try-catch-finally blocks Method invoked by the garbage collector before an object is reclaimed, used for cleanup operations</description></item><item><title>Collection</title><link>https://tiationg-kho.github.io/blog/2024/06/13/collection/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/collection/</guid><description>Collection A collection in Java is a framework that provides an architecture to store and manipulate a group of objects Collection Ordering Duplicates Null Values Key Characteristics ArrayList Ordered (index) Yes Yes Resizable array and good for random access and iterating LinkedList (as queue) FIFO Yes Yes Doubly-linked list ArrayDeque (as queue) FIFO Yes No Resizable array ArrayDeque (as stack) LIFO Yes No Resizable array PriorityQueue Natural ordering Yes No Elements are ordered by default comparator or provided one TreeSet Sorted No No Elements are sorted and unique HashSet Unordered No Yes Hashtable based LinkedHashSet Insertion order No Yes Hashtable and linked list based TreeMap Sorted Keys: No, Values: Yes Keys: No, Values: Yes Red-Black tree Hashtable Unordered Keys: No, Values: Yes Keys: No, Values: No Legacy HashMap Unordered Keys: No, Values: Yes Keys: Once, Values: Yes Hashtable based (array plus linked list or red-black tree) LinkedHashMap Insertion order Keys: No, Values: Yes Keys: Once, Values: Yes Hashtable and linked list based</description></item><item><title>String vs StringBuilder vs StringBuffer</title><link>https://tiationg-kho.github.io/blog/2024/06/13/string-vs-stringbuilder-vs-stringbuffer/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/string-vs-stringbuilder-vs-stringbuffer/</guid><description>String vs StringBuilder vs StringBuffer String StringBuilder StringBuffer Mutability Immutable Mutable Mutable Thread Safety Thread-safe Not thread-safe Thread-safe Use Case Suitable for values that won&amp;rsquo;t change Best for strings that are expected to change frequently in a single-threaded environment Suitable for strings that are modified by multiple threads</description></item><item><title>== vs equals vs hashCode</title><link>https://tiationg-kho.github.io/blog/2024/06/13/vs-equals-vs-hashcode/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/vs-equals-vs-hashcode/</guid><description>== vs equals vs hashCode == equals hashCode Definition Compares references for objects, values for primitives Compares the contents of two objects Returns a hash code value for the object Good Practice Always override equals() when a class&amp;rsquo;s identity is not solely based on memory location When overriding equals(), you must also override hashCode() to maintain the hash code contract</description></item><item><title>Checked Exceptions vs Unchecked Exceptions</title><link>https://tiationg-kho.github.io/blog/2024/06/13/checked-exceptions-vs-unchecked-exceptions/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/checked-exceptions-vs-unchecked-exceptions/</guid><description>Checked Exceptions vs Unchecked Exceptions Checked Exceptions Unchecked Exceptions Definition Exceptions that are checked at compile-time Exceptions that occur at runtime and are not checked at compile-time Handling Requirement Must be either caught using a try-catch-finally block or declared in the method signature using the throws keyword Not required to be caught or declared Use Case Related to external factors Related to logic issues Examples IOException, SQLException NullPointerException, ArrayIndexOutOfBoundsException</description></item><item><title>Generic</title><link>https://tiationg-kho.github.io/blog/2024/06/13/generic/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/generic/</guid><description>Generic Generics enable types (classes and interfaces) to be parameters when defining classes, interfaces, and methods Pros Stronger type checks at compile time No casting needed Ability to implement generic algorithms Declare Generics Generic class class Name&amp;lt;T1, T2, ...&amp;gt; { /* ... */ } Generic method public &amp;lt;T1, T2, ...&amp;gt; returnType methodName(T1 param) { /* ... */ } Generics Type Parameters They must be defined in the class or method signature Naming convention E for element (used extensively by the Java Collections Framework) K for key, and V for value N for number T for type Bound on Type Parameters eg.</description></item><item><title>Basic</title><link>https://tiationg-kho.github.io/blog/2024/06/13/basic/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/basic/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems basic complexity Time Complexity Constant. O(k) running time is independent of the input size Logarithmic. O(log(n)) like binary search or heap operations Linear. O(n) like nodes’ traversal Linearithmic. O(n * log(n)) most sort operations Quadratic.</description></item><item><title>Stream</title><link>https://tiationg-kho.github.io/blog/2024/06/13/stream/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/stream/</guid><description>Stream An abstraction that allows you to process sequences of elements in a functional style Stream Operations Intermediate Operations eg. filter Terminal Operations eg. toList public class Main { public static void main(String[] args) { List&amp;lt;String&amp;gt; myList = Arrays.asList(&amp;#34;apple&amp;#34;, &amp;#34;banana&amp;#34;, &amp;#34;cherry&amp;#34;); List&amp;lt;String&amp;gt; filteredList = myList.stream().filter(e -&amp;gt; e.startsWith(&amp;#34;b&amp;#34;)).toList(); System.out.println(filteredList); // [banana] } }</description></item><item><title>Functional Interface</title><link>https://tiationg-kho.github.io/blog/2024/06/13/functional-interface/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/functional-interface/</guid><description>Functional Interface An interface that contains exactly one abstract method
@FunctionalInterface
Used to mark an interface as a functional interface Usage with Lambda Expressions
Lambda expressions provide a simple way to implement functional interface Lambda expression syntax (parameters) -&amp;gt; { body } public class Main { public static void main(String[] args) { CheckEven func = (n) -&amp;gt; (n % 2) == 0; System.out.println(func.execute(2)); // true } } @FunctionalInterface interface CheckEven { boolean execute(int number); } Common Function Interface</description></item><item><title>Multithreading</title><link>https://tiationg-kho.github.io/blog/2024/06/13/multithreading/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/multithreading/</guid><description>Multithreading Multithreading is a Java feature that allows concurrent execution of two or more threads for maximum utilization of the CPU Process vs Thread A process is an executing program. It has its own memory space and resources A thread is a single unit of execution within a process. Multiple threads within the same process share the same memory space Main Thread When a Java application starts, it creates a main thread, which is responsible for executing the main method The main thread is the entry point of the program Create a Thread extends the Thread Class implements the Runnable Interface Use an ExecutorService for managing thread pool Lifecycle of a Thread New When a thread is created Use start() to become Runnable Runnable When the thread is ready to run but waiting for CPU time Use run() to become Running Running When the thread is executing Use sleep(), wait(), or join() to become Blocked Blocked When the thread is waiting for a resource Use notify(), or notifyAll() to become Runnable Terminated When the thread has finished executing synchronized Ensures that only one thread can execute a synchronized method or block at a time volatile Used to indicate that a variable&amp;rsquo;s value may be changed by different threads</description></item><item><title>I/O</title><link>https://tiationg-kho.github.io/blog/2024/06/13/i/o/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/i/o/</guid><description>I/O Java I/O is built around the concept of streams, which are sequences of data Type Byte Streams InputStream and its subclasses OutputStream and its subclasses Character Streams Reader and its subclasses Writer and its subclasses Buffered streams are more efficient as they reduce the number of I/O operations by using a buffer (eg. BufferedReader, BufferedWriter) Serialization is the process of converting objects to byte streams and vice versa, allowing it to be saved to a file or transferred over a network (eg.</description></item><item><title>SOLID Principle</title><link>https://tiationg-kho.github.io/blog/2024/06/13/solid-principle/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/solid-principle/</guid><description>SOLID Principle Single Responsibility Principle A class should have only one reason to change Open Closed Principle Software entities should be open for extension, but closed for modification Liskov Substitution Principle Objects of a superclass shall be replaceable with objects of a subclass Interface Segregation Principle Clients should not be forced to depend on interfaces they do not use Dependency Inversion Principle Both high level class and lower level class should depend on abstractions</description></item><item><title>Design Pattern</title><link>https://tiationg-kho.github.io/blog/2024/06/13/design-pattern/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/design-pattern/</guid><description>Design Pattern Singleton Pattern A creational pattern that restricts the instantiation of a class to a single instance eg. beans in IoC Container Decorator Pattern A structural pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class eg. @Transactional annotation Observer Pattern A behavioral pattern where an object/subject maintains a list of its dependents/observers and notifies them of any state changes eg.</description></item></channel></rss>