<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on Tiationg's Portfolio</title><link>https://tiationg-kho.github.io/tags/leetcode/</link><description>Recent content in LeetCode on Tiationg's Portfolio</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 14 Jun 2024 00:08:22 -0700</lastBuildDate><atom:link href="https://tiationg-kho.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>Tree</title><link>https://tiationg-kho.github.io/blog/2024/06/13/tree/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/tree/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems tree intro tree properties
tree is a special graph with properties that connected acyclic non-direction edges one path between any two vertices/nodes important tree concepts traversal of the tree depth/height of tree tree and its subtree tree node’s degree types of node root internal vs leaf parent vs child vs sibling root vs left boundary vs right boundary vs leaf predecessor vs successor lowest common ancestor (LCA) of two nodes types of tree binary tree every node has at most 2 children (left and right) binary search tree (BST) for each node nodes in left subtree have smaller keys nodes in right subtree have larger keys inorder traversal res is an ascending sorted list height-balanced binary tree depth of the subtrees of every node never differs by more than 1 perfect binary tree every internal node has exactly 2 child nodes every leaf nodes are at the same level complete binary tree every level is completely filled besides last level nodes in last level align left typically used in implementing heap full/strictly binary tree every node has exactly 0 or 2 children how to define tree node</description></item><item><title>Linked List</title><link>https://tiationg-kho.github.io/blog/2024/06/13/linked-list/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/linked-list/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems linked list intro sequential access
linked list doesn’t have index, but can simulate by counting total number of nodes
in memory, all the nodes spread every where
we can use linked list to implement queue/deque</description></item><item><title>Hashmap</title><link>https://tiationg-kho.github.io/blog/2024/06/13/hashmap/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/hashmap/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems hashmap intro Complexity search/add/delete in O(1) Implementation Array (we can think as lots of buckets) using a hash function to count key put that key’s value in that index Hash Collision Issue (when hash function told us to put in same idx) Solution Separate Chaining use linked list to store key-value pairs at that index Open Addressing find the next unused space adding 2-choice hashing use two hash functions still one hash table will decrease the number of hash collisions is useful for Rabin Karp (string pattern searching) Concept can reflect some map relation store key-value pairs key must be hashable if the number of keys is limited, can use array to simulate hashmap if we want to push and pop at same time, make sure to push first then pop, to avoid the issue when the push element is equal to the pop element pattern separate chaining</description></item><item><title>Binary Search</title><link>https://tiationg-kho.github.io/blog/2024/06/13/binary-search/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/binary-search/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems binary search intro # approach 1 # search in a sorted array for specific val # or search in sth’s range class Solution: def binary_search(self, nums, TARGET): left, right, boundary = 0, len(nums) - 1, - 1 while left &amp;lt;= right: m = (left + right) // 2 if nums[m] &amp;gt; TARGET: right = m - 1 elif nums[m] == TARGET: boundary = m break else: left = m + 1 return boundary # approach 2 # search in a sorted array for most close val to specific val # or search in sth’s range class Solution: def binary_search(self, nums, LIMIT): left, right, boundary = LOW_BOUND, UP_BOUND, - 1 def valid(PARAMETERS): SOME OPS DUE TO LIMIT return BOOL while left &amp;lt;= right: m = (left + right) // 2 if valid(m): boundary = m right = m - 1 # or left = m + 1 else: left = m + 1 # or right = m - 1 return boundary an efficient sorted array search algorithm can search for specific val can search for most close val to specific val can make a binary decision to shrink the search range time O(log(n)), space O(1) left and right can be a range from sorted array’s start and end sth’s low_bound and up_bound use a boundary (ptr) to record the current best/valid answer, then try to get better one pattern search in a sorted array for specific val</description></item><item><title>Heap</title><link>https://tiationg-kho.github.io/blog/2024/06/13/heap/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/heap/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems heap intro heap is a data structure (binary heap)
support insert in O(log(n)) insert as last element swim up the last element support delete_min or delete_max in O(log(n)) swap the top element with last element pop last element (which is old top element) sink down the (new) top element heapify(nums) takes O(n) time checking and performing sink down start from last element to top element why sink down every element is not O(nlogn) time because the higher layer, which node would cost more, actually have few nodes inside the layer O(1) to get the min val in min heap, or max val in max heap get the top element min heap</description></item><item><title>String</title><link>https://tiationg-kho.github.io/blog/2024/06/13/string/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/string/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems string intro terms palindrome use two pointers odd length or even length anagram use hashmap need to have same length isomorphic use hashmap build bijection mapping relation strobogrammatic number a number whose numeral is rotationally symmetric eg.</description></item><item><title>Trie</title><link>https://tiationg-kho.github.io/blog/2024/06/13/trie/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/trie/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems trie intro class TrieNode: def __init__(self): self.children = {} self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -&amp;gt; None: node = self.root for c in word: if c not in node.</description></item><item><title>Array</title><link>https://tiationg-kho.github.io/blog/2024/06/13/array/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/array/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems array array intro array contiguous in memory in dynamic arrays, amortized O(1) for appending array pattern traverse most common operation in array use Boyer Moore vote algorithm can find possible majority element(s) first travserse (finding candidate(s)) if this element is existing candidate, then increment voting count for if we do not have enough candidate(s), then add new candidate if this element is not a candidate, then decrement each existing voting count and remove candidate(s) if needed second traverse (verifying candidate(s)) calc the frequency of candidate(s) filter the final res notice: the order of these steps matters def get_top_k_majority(k): cand_vote = {} for num in nums: if num in cand_vote: cand_vote[num] += 1 elif len(cand_vote) &amp;lt; k: cand_vote[num] = 1 else: for c in list(cand_vote.</description></item><item><title>Stack And Queue</title><link>https://tiationg-kho.github.io/blog/2024/06/13/stack-and-queue/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/stack-and-queue/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems stack and queue intro stack
last in, first out recursion and function calls are implemented with stack behind the scene implementation array top pointer pointing to the top of the stack (usually the next unused space) when inserting an item, we set the value at the pointer to the item and increment the pointer by 1 when removing an item, we decrease the pointer by 1 tips compare cur element with stack[- 1] element then decide next steps accordingly # init the stack stack = [] # push 5 into the stack, O(1) stack.</description></item><item><title>Backtracking</title><link>https://tiationg-kho.github.io/blog/2024/06/13/backtracking/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/backtracking/</guid><description> Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems backtracking intro backtracking like dfs on a tree if a problem need try and error (make decisions) to enum every res, then use backtracking making decisions each round we got multi choices (must pick one) each round we choose sth or not choose notice elements are duplicate or unique if so, we need to take care of pruning notice elements can be chosen repeatedly or not if not, we need to maintain a memo notice that inside backtracking, we can use the boolean value as a return value to indicate whether there is a valid answer or not def backtrack(res, path, count, visited, index/node): if BOUND_REACHED: if GOAL_REACHED: RECORD_RESULT return for CHOCIE in CHOICES: if CHOICE is VALID: MAKE_CHOICE backtrack(res, path, count, visited, index/node) UNDO_CHOICE pattern subset a subset is composed of none or some or all elements from a set permutation a permutation is an ordered selection of a certain number of elements from a set combination a combination is an unordered selection of a certain number of elements from a set backtracking with constraints make choices and backtrack based on certain constraints or conditions</description></item><item><title>Graph</title><link>https://tiationg-kho.github.io/blog/2024/06/13/graph/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/graph/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems graph intro A graph is most commonly stored as a hashmap/list of adjacency lists/sets: for each vertex, store a list/set of its neighbors how to build graph is important often use elements inside set can be tuples graph = defaultdict(set) notice: tree is a special graph with properties that connected acyclic non-direction edges one path between any two vertices/nodes graph dfs pattern DFS time O(|V| + |E|) space O(|V|) for visited hashset, and recursion stack (not counting building graph) DFS is better at searching for long paths memorizing res for long paths detecting cycles # dfs graph = defaultdict(set) for p, q in edges: graph[p].</description></item><item><title>Bit Manipulation</title><link>https://tiationg-kho.github.io/blog/2024/06/13/bit-manipulation/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/bit-manipulation/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems bit manipulation intro # bitmasking # start from: mask = 0 # checking: mask &amp;amp; 1&amp;lt;&amp;lt;k == 0, if equals 0 means not mask 1&amp;lt;&amp;lt;k yet # masking: mask = mask | 1&amp;lt;&amp;lt;k # notice: we can also use &amp;#34;mask = mask ^ 1&amp;lt;&amp;lt;k&amp;#34; to mask for different purpose (toggle) mask = 0 bin(mask) # 0b0 mask &amp;amp; 1&amp;lt;&amp;lt;3 # 0 mask |= 1&amp;lt;&amp;lt;3 # 8 bin(mask) # 0b1000 mask &amp;amp; 1&amp;lt;&amp;lt;3 # 8 mask &amp;amp; 1&amp;lt;&amp;lt;5 # 0 # xor 5 ^ 5 # 0 5 ^ 5 ^ 3 # 3 # shift &amp;gt;&amp;gt; &amp;lt;&amp;lt; # not ~ # turn int number to 4-byte string (length = 4) # 256 == 8 bits == 1 byte bin(0xff) # &amp;#39;0b11111111&amp;#39; def int_to_string(val): byte_array = [(val &amp;gt;&amp;gt; (i * 8)) &amp;amp; 0xFF for i in range(4)][::- 1] char_array = [chr(byte) for byte in byte_array] string = &amp;#39;&amp;#39;.</description></item><item><title>Dynamic Programming</title><link>https://tiationg-kho.github.io/blog/2024/06/13/dynamic-programming/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/dynamic-programming/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems dynamic programming intro dp solving bigger problems using smaller problems while saving results to avoid repeated calculations dp problem is about count of ways minimum maximum a problem is a dp problem if it satisfy three conditions the problem can be divided into subproblems, and its optimal solution can be constructed from optimal solutions of the subproblems (optimal substructure) the subproblems overlap no aftereffect example of problem has optimal substructure but subproblems do not overlap merge sort so we use divide and conquer not dp to solve merge sort dp vs greedy in dp, we solve overall problem by combining the solutions about subproblems in greedy, we make a series of localized optimal choices without considering the overall problem two approaches of dp top-down approach (memoization) dfs and cache table bottom-up approach (tabulation) for loop and dp table steps of bottom-up dp define how to divide into smaller subproblems create dp table to store results for these subproblems fill dp table for base cases find out the formula about how to combine subproblems result to larger problem&amp;rsquo;s result start for loop and use formula we just found to fill rest of dp table pattern 2D use dp[i][j] cur states comes from previous states which record in 2D dp table use a 2D array for memo knapsack use dp[i] dp table&amp;rsquo;s size is the volume of the knapsack, and dp[i] is the value of size i knapsack 0-1 knapsack one item can only be selected once for num in nums: for total in range(target, num - 1, - 1): complete knapsack one item can be selected several times for num in nums: for total in range(1, target + 1): combination knapsack consider the select ways of item for num in nums: for total in range(1, target + 1): permutation knapsack consider the select order of item for total in range(1, target + 1): for num in nums: linear sequence use dp[i] cur states comes from previous states which record in dp table or use some variable to record previous states to replace using the whole dp table LIS use dp[i] LIS (longest increasing subsequence) problem O(n**2) approach (linear sequence) dp[i] means the length of LIS which ends in i O(nlogn) approach (patience sort and greedy and binary search) dp[i] means the smallest last num when subseq&amp;rsquo;s length is i+1 double sequence use dp[i][j] can solve LCS (longest common subsequence) problem eg.</description></item><item><title>Greedy</title><link>https://tiationg-kho.github.io/blog/2024/06/13/greedy/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/greedy/</guid><description> Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems greedy intro greedy algorithms is to pick the locally optimal solution at each step with the hope of finding the global optimum dp vs greedy in dp, we solve overall problem by combining the solutions about subproblems in greedy, we make a series of localized optimal choices without considering the overall problem pattern greedy we need to make the locally optimal choice sometimes, use sorting or heap can help us make greedy choice</description></item><item><title>Math</title><link>https://tiationg-kho.github.io/blog/2024/06/13/math/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/math/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems math intro carry in addition, carry is a number that moves to the next column when adding two nums and their column sum is too big for that digit (should consider we are using which base) division using division help us constructing a num without converting it to a string catalan number Cn = C(2n, n) / (n+1) or (2n)!</description></item><item><title>Segment Tree</title><link>https://tiationg-kho.github.io/blog/2024/06/13/segment-tree/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/segment-tree/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems segment tree intro Aspect Prefix Sum Difference Array Segment Tree Primary Purpose range sum queries range updates range queries, and range updates Operation Time Sum Query: O(1) Update: O(1) Query: O(logC) or O(logn); Update: O(logC) or O(logn) Reconstruction get original array from diff of elements get original array from prefix sum of elements N/A Use Case static arrays cumulative updates interval-based manipulations segment tree is a tree where each node is an interval tree based is more easy to understand build tree O(n) or use dynamic build, only build node when update() and query(), cost O(logC) (C is max val of num we assign) point modify O(logC) or O(logn) range query O(logC) or O(logn) sum count max other related aggregations range modify O(logC) if using lazy propagation can have multiple lazy variables depends on how many operations need push_down(), push_up(), update(), query() will be implemented differently depends on the diff type of range query and range modify # sum type # non dynamic build # non range modification # non lazy propagation class Node: def __init__(self, start, end): self.</description></item><item><title>Basic</title><link>https://tiationg-kho.github.io/blog/2024/06/13/basic/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/basic/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems basic complexity Time Complexity Constant. O(k) running time is independent of the input size Logarithmic. O(log(n)) like binary search or heap operations Linear. O(n) like nodes’ traversal Linearithmic. O(n * log(n)) most sort operations Quadratic.</description></item></channel></rss>