<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Stack on Tiationg's Portfolio</title><link>https://tiationg-kho.github.io/tags/stack/</link><description>Recent content in Stack on Tiationg's Portfolio</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 14 Jun 2024 00:08:22 -0700</lastBuildDate><atom:link href="https://tiationg-kho.github.io/tags/stack/index.xml" rel="self" type="application/rss+xml"/><item><title>Stack And Queue</title><link>https://tiationg-kho.github.io/blog/2024/06/13/stack-and-queue/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>https://tiationg-kho.github.io/blog/2024/06/13/stack-and-queue/</guid><description>Starred by 25+ users, GitHub Repo: LeetCode Pattern 500 offers:
500 solutions for LeetCode problems in Python and Java 17 notes on essential concepts related to data structures and algorithms 130 patterns for solving LeetCode problems stack and queue intro stack
last in, first out recursion and function calls are implemented with stack behind the scene implementation array top pointer pointing to the top of the stack (usually the next unused space) when inserting an item, we set the value at the pointer to the item and increment the pointer by 1 when removing an item, we decrease the pointer by 1 tips compare cur element with stack[- 1] element then decide next steps accordingly # init the stack stack = [] # push 5 into the stack, O(1) stack.</description></item></channel></rss>